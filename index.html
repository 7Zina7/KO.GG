<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Website</title>
    <style>
        body {
            background-color: #add8e6; /* Light blue */
            margin: 0;
            font-family: Arial, sans-serif;
        }
        nav {
            width: 100vw;
            background: #111;
            color: #fff;
            box-shadow: 0 2px 8px #0001;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 10;
        }
        nav div {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 64px;
        }
        nav a {
            text-decoration: none;
        }
        nav span {
            font-size: 2.6rem;
            font-weight: bold;
            letter-spacing: 2px;
            color: #fff;
            background: linear-gradient(90deg,#4fa3d1,#357ca5);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            display: inline-block;
            line-height: 1;
        }
        .container {
            min-height: 160vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding-top: 80px; /* Added padding to prevent content from being hidden under the nav */
        }
        h1 {
            color: #222;
        }
        /* Add a large centered square */
        .center-square {
            width: 90vw;
            height: auto;
            min-height: 240vh;
            max-width: 1100px;
            max-height: 3600px;
            background: #8cc6ea; /* Lighter blue, but still darker than background */
            border-radius: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            box-shadow: 0 4px 32px rgba(0,0,0,0.08);
            padding-top: 40px;
        }
        @media (max-width: 700px) {
            .center-square {
                width: 99vw;
                height: auto;
                min-height: 270vh;
                max-width: 100vw;
                max-height: 4000px;
            }
        }
        .game-menu {
            display: flex;
            flex-direction: column;
            gap: 22px;
            justify-content: flex-start;
            align-items: stretch;
            margin: 0 auto 24px auto;
            max-width: 600px;
            width: 100%;
        }
        .game-menu button {
            padding: 28px 0;
            border: none;
            border-radius: 12px;
            background: #4fa3d1;
            color: #fff;
            font-size: 2.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: background 0.2s;
            width: 100%;
            margin: 0;
            box-shadow: 0 2px 8px #357ca522;
            letter-spacing: 1px;
        }
        .game-menu button:focus {
            outline: 3px solid #357ca5;
            outline-offset: 2px;
        }
        .game-menu button:hover {
            background: #357ca5;
        }
        .game-area {
            margin-top: 10px;
            width: 100%;
            min-height: 320px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* Sliding puzzle styles */
        .sliding-puzzle {
            display: grid;
            grid-template-columns: repeat(4, 50px);
            grid-template-rows: repeat(4, 50px);
            gap: 4px;
        }
        .sliding-tile {
            width: 50px;
            height: 50px;
            background: #fff;
            color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            border-radius: 6px;
            cursor: pointer;
            user-select: none;
        }
        .sliding-tile.empty {
            background: transparent;
            cursor: default;
        }
        .difficulty-menu {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 18px;
        }
        .difficulty-menu button {
            padding: 7px 16px;
            border: none;
            border-radius: 6px;
            background: #357ca5;
            color: #fff;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.2s;
        }
        .difficulty-menu button.selected,
        .difficulty-menu button:hover {
            background: #1d4e6c;
        }
        /* Responsive for puzzle sizes */
        .sliding-puzzle.small { grid-template-columns: repeat(3, 44px); grid-template-rows: repeat(3, 44px); }
        .sliding-puzzle.medium { grid-template-columns: repeat(4, 38px); grid-template-rows: repeat(4, 38px); }
        .sliding-puzzle.large { grid-template-columns: repeat(5, 32px); grid-template-rows: repeat(5, 32px); }
        .sliding-tile { font-size: 1rem; }

        /* Lobby styles */
        .lobby {
            padding-top: 90px;
            max-width: 420px;
            margin: auto;
            display: block !important;
        }
        .lobby h2 {
            color: #357ca5;
        }
        .lobby input, .lobby button {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 1rem;
        }
        .lobby button {
            background: #357ca5;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        .lobby button:hover {
            background: #1d4e6c;
        }
        #userList {
            margin-top: 18px;
            color: #234;
        }
        #lobbyChat {
            margin-top: 18px;
            background: #f7fafd;
            border-radius: 8px;
            padding: 10px;
            max-height: 120px;
            overflow-y: auto;
        }
        #mainContent {
            display: flex !important;
        }
        #gameInstructions {
            margin-bottom: 0 !important;
        }
        #gameWrapper > div[style*='margin-bottom:10px'],
        #gameWrapper > div[style*='margin-bottom:16px'] {
            margin-top: 0 !important;
        }
    </style>
</head>
<body>
        <nav style="width:100vw;background:#111;box-shadow:0 2px 8px #0001;position:fixed;top:0;left:0;z-index:10;">
            <div style="display:flex;justify-content:center;align-items:center;height:64px;">
                <a href="/" style="text-decoration:none;">
                    <span style="font-size:2.6rem;font-weight:bold;color:#fff;background:linear-gradient(90deg,#4fa3d1,#357ca5);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;display:inline-block;line-height:1;letter-spacing:2px;">KO[/]GG</span>
                </a>
            </div>
        </nav>
        <div class="lobby" id="lobby" style="display:none;"></div>
        <div class="container" id="mainContent" style="display:flex;">
            <div class="center-square">
                <div style="text-align:center; width:100%;">
                    <h2>Flappy Square</h2>
                    <div style="margin-bottom:18px;font-size:1.35em;color:#234;max-width:520px;margin-left:auto;margin-right:auto;line-height:1.6;">
                      <b>Flappy Square?</b> It sounds awfully familiar....... Wait..... <b>Flappy Birds?!</b> What are <b>YOU</b> doing here?<br><br>
                      A game of Flappy Square? <b>EZ!</b> But is it really just a normal game......Strange things seem to be happening.<br>
                      <span style="color:#b00;font-family:monospace;">Glitch--010100 S-OM--E--THING-----I------S 0010101--WRONG!------ERROR CODE 1010101.........................................</span><br><br>
                      Welcome to a game of Flappy Square! The shapes never lie or cry.......You think that this game will be easy? Think again........ Fight your shape friend and win. Winner survives the other dies. Don't say I didn't warn you!
                    </div>
                    <div style="text-align:center;margin-bottom:22px;">
                      <button id="playBtn" style="padding:14px 44px;font-size:1.5em;font-weight:bold;border-radius:12px;background:#1d4e6c;color:#fff;border:none;box-shadow:0 2px 8px #357ca555;cursor:pointer;transition:background 0.2s;">LET'S PLAY</button>
                    </div>
                    <div id="gameWrapper" style="display:none;">
                        <div id="gameInstructions" style="margin-bottom:10px;font-size:1.13em;color:#234;font-weight:bold;min-height:28px;text-align:center;"></div>
                        <div class="game-area" id="gameArea"></div>
                        <div style="margin-bottom:16px;">
                            <button id="optionsBtn" style="padding:8px 18px;border-radius:8px;background:#357ca5;color:#fff;border:none;cursor:pointer;font-size:1em;">Options</button>
                        </div>
                        <div id="optionsPanel" style="display:none;margin-bottom:18px;padding:16px 20px;background:#e6f0fa;border-radius:12px;box-shadow:0 2px 8px #357ca522;max-width:340px;margin:auto;">
                            <label>Bird Color:
                                <input type="color" id="birdColorInput" value="#ffd700" style="margin-left:8px;">
                            </label>
                            <br><br>
                            <label>Bird Shape:
                                <select id="birdShapeInput" style="margin-left:8px;">
                                    <option value="circle">Circle</option>
                                    <option value="square">Square</option>
                                    <option value="triangle">Triangle</option>
                                </select>
                            </label>
                            <br><br>
                            <button id="closeOptionsBtn" style="padding:6px 16px;border-radius:6px;background:#357ca5;color:#fff;border:none;cursor:pointer;">Close</button>
                        </div>
                        <canvas id="flappyCanvas" width="400" height="600" style="background:#87ceeb;border-radius:12px;box-shadow:0 2px 16px #357ca555;"></canvas>
                        <div style="margin-top:10px;">
                          <button id="fullscreenBtn" style="padding:7px 18px;border-radius:8px;background:#357ca5;color:#fff;border:none;cursor:pointer;font-size:1em;">Full Screen</button>
                        </div>
                        <div style="margin-top:12px;font-size:1.1em;">Press <b>Space</b> or tap/click to jump!</div>
                        <div id="flappyScore" style="margin-top:8px;font-size:1.2em;font-weight:bold;"></div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Multiplayer scripts removed -->
        <script src="sliding-puzzle.js"></script>
        <script src="sudoku.js"></script>
        <script src="memory-match.js"></script>
        <script src="word-search.js"></script>
        <script src="lights-out.js"></script>
        <script src="maze.js"></script>
        <script src="simon-says.js"></script>
        <script src="nonogram.js"></script>
        <script src="hanoi.js"></script>
        <script src="color-pattern.js"></script>
        <script>
    // Game initialization and logic here
    // For example, setting up event listeners for game actions, starting the game, etc.
</script>
<script>
document.addEventListener('DOMContentLoaded', function() {
(function flappyBirdGame() {
    const canvas = document.getElementById('flappyCanvas');
    if (!canvas) return;
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    // Track if fullscreen was entered via the button and not exited
    let enteredFullscreenViaBtn = false;
    let inFullscreen = false;
    function getFullscreenElement() {
        return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
    }
    function isCanvasInFullscreen() {
        return getFullscreenElement() === canvas;
    }
    function handleFullscreenChange() {
        inFullscreen = !!isCanvasInFullscreen();
        if (!inFullscreen) enteredFullscreenViaBtn = false;
    }
    fullscreenBtn.onclick = () => {
        if (canvas.requestFullscreen) canvas.requestFullscreen();
        else if (canvas.webkitRequestFullscreen) canvas.webkitRequestFullscreen();
        else if (canvas.mozRequestFullScreen) canvas.mozRequestFullScreen();
        else if (canvas.msRequestFullscreen) canvas.msRequestFullscreen();
        // Set flag on button click
        setTimeout(() => {
            if (isCanvasInFullscreen()) enteredFullscreenViaBtn = true;
        }, 100);
    };
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleFullscreenChange);
    document.addEventListener('MSFullscreenChange', handleFullscreenChange);
    // --- Add/update instructions panel logic ---
    const instructionsPanel = document.getElementById('gameInstructions');
    let currentInstruction = '';
    function updateInstructions() {
        if (dashMode) {
            currentInstruction = 'Geometry Dash! Press Space or tap to jump!';
        } else if (knifeMode) {
            currentInstruction = 'Rock Dodge! Use  and  or tap/click sides to move.';
        } else {
            currentInstruction = 'Flappy Mode! Press Space or tap/click to jump.';
        }
        if (instructionsPanel) instructionsPanel.textContent = currentInstruction;
    }
    // (restore original game element sizes and scaling for 400x600 canvas)
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    let birdR = 14; // was 18, now smaller
    let birdX = 80;
    let blockY = H - 40;
    let pipeGap = 140;
    let pipeW = 60;
    let pipeSpeed = 2.5;
    let jump = -8;
    let gravity = 0.5;
    let blockSpeed = 7;
    let knifeW = 18, knifeH = 38, knifeSpeed = 6;
    let knifeInterval = 30; // Add this for knife spawn rate
    let blockR = birdR; // Add this for block collision radius

    let birdY = H/2, birdV = 0;
    let pipes = [], frame = 0, score = 0, best = 0, gameOver = false, started = false;
    let birdColor = '#ffd700';
    let birdShape = 'circle';
    let clouds = [
        {x: 60, y: 80, w: 80, h: 30, speed: 0.5},
        {x: 220, y: 50, w: 100, h: 36, speed: 0.3},
        {x: 320, y: 120, w: 60, h: 22, speed: 0.4}
    ];
    // Knife Dodge game state
    let knifeMode = false;
    let knives = [], knifeFrame = 0;
    let blockX = W/2, blockV = 0;
    // Knife mode background transition
    let redTransition = 0; // 0 to 1
    let redTransitionActive = false;
    // Options UI
    const optionsBtn = document.getElementById('optionsBtn');
    const optionsPanel = document.getElementById('optionsPanel');
    const birdColorInput = document.getElementById('birdColorInput');
    const birdShapeInput = document.getElementById('birdShapeInput');
    const closeOptionsBtn = document.getElementById('closeOptionsBtn');
    optionsBtn.onclick = () => { optionsPanel.style.display = 'block'; };
    closeOptionsBtn.onclick = () => { optionsPanel.style.display = 'none'; };
    birdColorInput.oninput = () => { birdColor = birdColorInput.value; };
    birdShapeInput.onchange = () => { birdShape = birdShapeInput.value; };
    function reset() {
        birdY = H/2; birdV = 0; pipes = []; frame = 0; score = 0; gameOver = false; started = false; knifeMode = false;
        knives = []; knifeFrame = 0; blockX = W/2; blockV = 0;
        readyToStart = false;
        altModePhase = 0;
        altModeCounter = 0;
        currentMode = 'flappy';
        bouldersDodged = 0;
        document.getElementById('flappyScore').textContent = '';
        let overlay = document.getElementById('gameOverScreen');
        if (overlay) overlay.remove();
        updateInstructions();
    }
    function drawClouds() {
        ctx.save();
        clouds.forEach(cloud => {
            ctx.globalAlpha = 0.6;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(cloud.x, cloud.y, cloud.w/2, cloud.h/2, 0, 0, 2*Math.PI);
            ctx.fill();
            ctx.globalAlpha = 1;
        });
        ctx.restore();
    }
    function updateClouds() {
        clouds.forEach(cloud => {
            cloud.x -= cloud.speed;
            if (cloud.x + cloud.w/2 < 0) cloud.x = W + cloud.w/2;
        });
    }
    function drawBird(x=birdX, y=birdY, shape=birdShape, color=birdColor) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(Math.min(Math.PI/4, birdV/10));
        ctx.fillStyle = color;
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        if (shape === 'circle') {
            ctx.beginPath();
            ctx.ellipse(0, 0, birdR, birdR, 0, 0, 2*Math.PI); // perfect circle
            ctx.fill();
            ctx.stroke();
        } else if (shape === 'square') {
            ctx.fillRect(-birdR, -birdR, birdR*2, birdR*2); // perfect square
            ctx.strokeRect(-birdR, -birdR, birdR*2, birdR*2);
        } else if (shape === 'triangle') {
            ctx.beginPath();
            ctx.moveTo(0, -birdR);
            ctx.lineTo(birdR, birdR);
            ctx.lineTo(-birdR, birdR);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
        ctx.restore();
    }
    function drawPipes() {
        ctx.fillStyle = '#228B22';
        pipes.forEach(p => {
            ctx.fillRect(p.x, 0, pipeW, p.top);
            ctx.fillRect(p.x, p.top+pipeGap, pipeW, H-p.top-pipeGap);
        });
    }
    function drawKnives() {
        ctx.save();
        knives.forEach(k => {
            // Draw a rock: gray ellipse with a dark outline and some cracks
            ctx.beginPath();
            ctx.ellipse(k.x + knifeW/2, k.y + knifeH/2, knifeW/2, knifeH/2, 0, 0, 2 * Math.PI);
            ctx.fillStyle = '#888';
            ctx.fill();
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.stroke();
            // Draw cracks
            ctx.strokeStyle = '#bbb';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(k.x + knifeW/2, k.y + knifeH/2);
            ctx.lineTo(k.x + knifeW/2 + 4, k.y + knifeH/2 + 8);
            ctx.moveTo(k.x + knifeW/2 - 3, k.y + knifeH/2 - 5);
            ctx.lineTo(k.x + knifeW/2 + 5, k.y + knifeH/2 - 2);
            ctx.stroke();
        });
        ctx.restore();
    }
    function drawBlock() {
        drawBird(blockX, blockY, birdShape, birdColor);
    }
    function drawRedTransition() {
        if (redTransition > 0) {
            let grad = ctx.createLinearGradient(0, 0, 0, H);
            grad.addColorStop(0, `rgba(200,0,0,${Math.min(1, redTransition)})`);
            grad.addColorStop(Math.max(0.01, redTransition), `rgba(200,0,0,${Math.min(1, redTransition)})`);
            grad.addColorStop(Math.min(1, redTransition + 0.05), 'rgba(200,0,0,0.0)');
            grad.addColorStop(1, 'rgba(200,0,0,0.0)');
            ctx.save();
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
        }
    }
    // Game Over UI
    let showGameOver = false;
    let lastScore = 0;
    let lastBest = 0;
    let lastBouldersDodged = 0; // Track last boulders dodged
    let bouldersDodged = 0; // Track current run's boulders dodged
    let cyclesSurvived = 0; // Track full cycles completed
    let lastCyclesSurvived = 0; // For overlay
    function showGameOverScreen() {
        const wrapper = document.getElementById('gameWrapper');
        if (!wrapper) return;
        // Remove any existing overlays
        let existing = document.getElementById('gameOverScreen');
        if (existing) {
            if (existing._removeRaf) existing._removeRaf();
            if (existing._removeFS) existing._removeFS();
            if (existing.parentNode) existing.parentNode.removeChild(existing);
        }
        // Normal overlay
        let overlay = document.createElement('div');
        overlay.id = 'gameOverScreen';
        // Determine overlay color: blue if died in fullscreen entered via button
        let useBlue = enteredFullscreenViaBtn && isCanvasInFullscreen();
        let isFS = isCanvasInFullscreen();
        // --- Add Levels Survived ---
        let levelsSurvived = cyclesSurvived; // Now tracks full cycles only
        // Unified blue overlay for both fullscreen and non-fullscreen
        let blueMain = '#5bbcff';
        let blueShadow = '0 0 32px 8px #5bbcff,0 6px 48px #0a3b6cbb';
        let overlayBoxStyle = `background:rgba(30,30,60,0.93);padding:36px 32px 28px 32px;border-radius:22px;box-shadow:${blueShadow};max-width:min(380px,98vw);width:96%;text-align:center;backdrop-filter:none;border:none;transition:all 0.2s;`;
        let titleFont = '2.1em';
        let statFont = '1.3em';
        let subFont = '1.1em';
        overlay.innerHTML = `
          <div style="${overlayBoxStyle}">
            <div style="font-size:${titleFont};font-weight:bold;color:${blueMain};margin-bottom:16px;text-shadow:0 2px 8px #5bbcff99;">Game Over</div>
            <div style="font-size:${statFont};color:${blueMain};margin-bottom:14px;text-shadow:0 1px 6px #0006;">Pillars Passed: <b>${lastScore}</b></div>
            <div style="font-size:${subFont};color:${blueMain};margin-bottom:12px;text-shadow:0 1px 6px #0006;">Boulders Dodged: <b>${lastBouldersDodged}</b></div>
            <div style="font-size:${subFont};color:${blueMain};margin-bottom:12px;text-shadow:0 1px 6px #0006;">Levels Survived: <b>${levelsSurvived}</b></div>
            <div style="font-size:${subFont};color:${blueMain};margin-bottom:22px;text-shadow:0 1px 6px #0006;">All-Time Best: <b>${lastBest}</b></div>
            <button id="tryAgainBtn" style="padding:14px 40px;font-size:1.25em;font-weight:bold;border-radius:12px;background:#357ca5;color:#fff;border:none;box-shadow:0 2px 8px #357ca555;cursor:pointer;margin-right:16px;">Try Again</button>
            <button id="quitBtn" style="padding:14px 40px;font-size:1.25em;font-weight:bold;border-radius:12px;background:#5bbcff;color:#fff;border:none;box-shadow:0 2px 8px #357ca555;cursor:pointer;">Quit</button>
          </div>
        `;
        // Overlay positioning logic
        function updateOverlayPosition() {
            if (overlay.parentNode !== document.body) document.body.appendChild(overlay);
            // Always cover only the canvas, even in fullscreen
            const rect = canvas.getBoundingClientRect();
            overlay.style.display = 'flex';
            overlay.style.position = 'absolute';
            overlay.style.left = rect.left + window.scrollX + 'px';
            overlay.style.top = rect.top + window.scrollY + 'px';
            overlay.style.width = rect.width + 'px';
            overlay.style.height = rect.height + 'px';
            overlay.style.flexDirection = 'column';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.background = isFS ? 'rgba(10,20,40,0.82)' : 'rgba(30,0,0,0.82)';
            overlay.style.zIndex = '1000';
            overlay.style.pointerEvents = 'auto';
            overlay.style.backdropFilter = isFS ? 'blur(4px)' : 'none';
        }
        // Initial append (but only once)
        if (!document.getElementById('gameOverScreen')) document.body.appendChild(overlay);
        // Animation frame for alignment
        let rafId;
        function keepOverlayAligned() {
            updateOverlayPosition();
            rafId = requestAnimationFrame(keepOverlayAligned);
        }
        keepOverlayAligned();
        // Button logic for overlay only
        function setupOverlayButtons(ov, tryId, quitId) {
            ov.querySelector(`#${tryId}`).onclick = function() {
                if (ov._removeRaf) ov._removeRaf();
                if (ov._removeFS) ov._removeFS();
                if (ov.parentNode) ov.parentNode.removeChild(ov);
                reset();
                started = true;
            };
            ov.querySelector(`#${quitId}`).onclick = function() {
                if (ov._removeRaf) ov._removeRaf();
                if (ov._removeFS) ov._removeFS();
                if (ov.parentNode) ov.parentNode.removeChild(ov);
                var playBtn = document.getElementById('playBtn');
                if (playBtn) playBtn.style.display = 'inline-block';
            };
        }
        setupOverlayButtons(overlay, 'tryAgainBtn', 'quitBtn');
        // Listen for fullscreen changes and re-append overlay if needed
        function onFullscreenChangeOverlay() { updateOverlayPosition(); }
        document.addEventListener('fullscreenchange', onFullscreenChangeOverlay);
        document.addEventListener('webkitfullscreenchange', onFullscreenChangeOverlay);
        document.addEventListener('mozfullscreenchange', onFullscreenChangeOverlay);
        document.addEventListener('MSFullscreenChange', onFullscreenChangeOverlay);
        // Clean up the animation frame and listeners when overlay is removed
        overlay._removeRaf = () => { if (rafId) cancelAnimationFrame(rafId); };
        overlay._removeFS = () => {
            document.removeEventListener('fullscreenchange', onFullscreenChangeOverlay);
            document.removeEventListener('webkitfullscreenchange', onFullscreenChangeOverlay);
            document.removeEventListener('mozfullscreenchange', onFullscreenChangeOverlay);
            document.removeEventListener('MSFullscreenChange', onFullscreenChangeOverlay);
        };
        // Robust cleanup on removal
        const observer = new MutationObserver(() => {
            if (!document.getElementById('gameOverScreen')) {
                if (overlay._removeRaf) overlay._removeRaf();
                if (overlay._removeFS) overlay._removeFS();
                observer.disconnect();
            }
        });
        observer.observe(document.body, {childList:true, subtree:true});
    }
    function draw() {
        ctx.clearRect(0,0,W,H);
        // Draw instructions inside canvas at the top
        ctx.save();
        ctx.font = 'bold 1.18em Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#234';
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 6;
        ctx.fillText(currentInstruction, W/2, 36);
        ctx.restore();
        drawClouds();
        if (dashMode) {
            drawDashMode();
            return;
        }
        if (!knifeMode) {
            drawPipes();
            drawBird();
            // Draw overlay if not started
            if (!started && !readyToStart && !gameOver) {
                ctx.save();
                ctx.globalAlpha = 0.7;
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(birdX, birdY, birdR+8, birdR+8, 0, 0, 2*Math.PI);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.strokeStyle = '#357ca5';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.ellipse(birdX, birdY, birdR+8, birdR+8, 0, 0, 2*Math.PI);
                ctx.stroke();
                ctx.font = 'bold 1.1em Arial';
                ctx.fillStyle = '#357ca5';
                ctx.textAlign = 'center';
                ctx.fillText('Click anywhere to start', birdX, birdY - birdR - 18);
                ctx.restore();
            }
        } else {
            drawBlock();
            drawKnives();
        }
        // Only draw red transition if in rock mode or during transition
        if (knifeMode || redTransitionActive) {
            drawRedTransition();
        }
    }
    function update() {
        if (!started) return;
        // Enter Geometry Dash after boulders for current nextDashLevel
        if (!dashMode && bouldersDodged >= 10) {
            startDashMode();
            return;
        }
        if (dashMode) {
            updateDashMode();
            return;
        }
        // Alternating mode logic
        if (score >= 5) {
            if (altModePhase === 0) {
                altModePhase = 1;
                altModeCounter = 0;
                currentMode = 'rock';
                knifeMode = true;
                document.getElementById('flappyScore').textContent = 'Rock Dodge! Use ︎ and ︎ or tap/click sides to move.';
                redTransition = 0;
                redTransitionActive = true;
                updateInstructions();
            } else {
                let since5 = score - 5;
                let newCounter = Math.floor(since5 / 3);
                if (newCounter !== altModeCounter) {
                    altModeCounter = newCounter;
                    if (currentMode === 'flappy') {
                        currentMode = 'rock';
                        knifeMode = true;
                        document.getElementById('flappyScore').textContent = 'Rock Dodge! Use ︎ and ︎ or tap/click sides to move.';
                        redTransition = 0;
                        redTransitionActive = true;
                        updateInstructions();
                    } else {
                        currentMode = 'flappy';
                        knifeMode = false;
                        document.getElementById('flappyScore').textContent = '';
                        redTransition = 0;
                        updateInstructions();
                    }
                }
            }
        }
        if (!knifeMode) {
            birdV += gravity;
            birdY += birdV;
            updateClouds();
            if (frame % 90 === 0) {
                let top = 60 + Math.random()*(H-pipeGap-120);
                pipes.push({x:W, top});
            }
            pipes.forEach(p => p.x -= pipeSpeed);
            if (pipes.length && pipes[0].x+pipeW<0) { pipes.shift(); score++; }
            // Collision
            pipes.forEach(p => {
                if (birdX+birdR>p.x && birdX-birdR<p.x+pipeW && (birdY-birdR<p.top || birdY+birdR>p.top+pipeGap)) gameOver = true;
            });
            if (birdY-birdR<0 || birdY+birdR>H) gameOver = true;
            if (score >= 5 && !knifeMode) {
                knifeMode = true;
                started = true;
                document.getElementById('flappyScore').textContent = 'Knife Dodge! Use ︎ and ︎ or tap/click sides to move.';
                redTransition = 0;
                redTransitionActive = true;
            }
            if (gameOver) {
                best = Math.max(best, score);
                lastScore = score;
                lastBest = best;
                lastBouldersDodged = bouldersDodged;
                showGameOver = true;
                showGameOverScreen(); // Show immediately on any game over
                document.getElementById('flappyScore').textContent = '';
                started = false;
            }
        } else {
            // Knife Dodge mode
            if (redTransitionActive && redTransition < 1) {
                redTransition += 0.025;
                if (redTransition >= 1) {
                    redTransition = 1;
                    redTransitionActive = false;
                }
            }
            updateClouds();
            if (knifeFrame % knifeInterval === 0) {
                let kx = Math.random()*(W-knifeW);
                knives.push({x:kx, y:-knifeH});
            }
            // Move block
            blockX += blockV;
            if (blockX-blockR < 0) blockX = blockR;
            if (blockX+blockR > W) blockX = W-blockR;
            // Collision
            knives.forEach(k => {
                if (blockX+blockR>k.x && blockX-blockR<k.x+knifeW && blockY+blockR>k.y && blockY-blockR<k.y+knifeH) {
                    gameOver = true;
                }
            });
            // Count boulders dodged: if a knife leaves the screen, increment
            let before = knives.length;
            knives.forEach(k => k.y += knifeSpeed);
            let afterKnives = knives.filter(k => k.y < H+knifeH);
            bouldersDodged += (before - afterKnives.length);
            knives = afterKnives;
            if (gameOver) {
                lastScore = score;
                lastBest = best;
                lastBouldersDodged = bouldersDodged;
                showGameOver = true;
                showGameOverScreen(); // Show immediately on boulder hit
                document.getElementById('flappyScore').textContent = '';
                started = false;
            }
            knifeFrame++;
        }
    }
    // Geometry Dash mode state
    let dashMode = false;
    let dashPlayer = { x: 60, y: 0, vy: 0, w: 28, h: 28, onGround: false };
    let dashObstacles = [];
    let dashFrame = 0;
    let dashGroundY = H - 60;
    let dashScore = 0;
    let dashGameOver = false;
    let dashLevel = 1; // current level being played
    let nextDashLevel = 1; // next level to play after cycle
    const dashLevelSettings = [
        // [speed, gravity, jump, spawnRate, minObsW, maxObsW, levelScore]
        [4.2, 0.7, -12, 60, 24, 36, 10],   // Level 1
        [5.2, 0.8, -13, 50, 22, 38, 14],   // Level 2
        [6.2, 0.92, -14, 42, 20, 40, 18],  // Level 3
        [7.2, 1.05, -15, 34, 18, 42, 22],  // Level 4
        [8.2, 1.18, -16, 28, 16, 44, 26],  // Level 5
    ];
    function getDashSettings() {
        return dashLevelSettings[Math.max(0, Math.min(dashLevel-1, dashLevelSettings.length-1))];
    }
    function resetDashMode() {
        const [speed, gravity, jump] = getDashSettings();
        dashPlayer = { x: 60, y: dashGroundY - 28, vy: 0, w: 28, h: 28, onGround: true };
        dashObstacles = [];
        dashFrame = 0;
        dashScore = 0;
        dashGameOver = false;
        dashSpeed = speed;
        dashGravity = gravity;
        dashJump = jump;
    }
    function startDashMode() {
        dashMode = true;
        dashLevel = nextDashLevel;
        resetDashMode();
        document.getElementById('flappyScore').textContent = 'Geometry Dash! Level ' + dashLevel;
        updateInstructions();
    }
    function drawDashMode() {
        // Draw ground
        ctx.fillStyle = '#222';
        ctx.fillRect(0, dashGroundY, W, H - dashGroundY);
        // Draw player (square)
        ctx.save();
        ctx.fillStyle = birdColor;
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.fillRect(dashPlayer.x, dashPlayer.y, dashPlayer.w, dashPlayer.h);
        ctx.strokeRect(dashPlayer.x, dashPlayer.y, dashPlayer.w, dashPlayer.h);
        ctx.restore();
        // Draw obstacles (spikes)
        dashObstacles.forEach(obs => {
            ctx.save();
            ctx.fillStyle = '#b00';
            ctx.beginPath();
            ctx.moveTo(obs.x, obs.y + obs.h);
            ctx.lineTo(obs.x + obs.w/2, obs.y);
            ctx.lineTo(obs.x + obs.w, obs.y + obs.h);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        });
        // Score and level
        ctx.save();
        ctx.font = 'bold 1.3em Arial';
        ctx.fillStyle = '#fff';
        ctx.fillText('Dash Score: ' + dashScore, W - 140, 38);
        ctx.font = 'bold 1.1em Arial';
        ctx.fillStyle = '#ffd700';
        ctx.fillText('Level ' + dashLevel, 80, 38);
        ctx.restore();
    }
    function updateDashMode() {
        dashFrame++;
        const [speed, gravity, jump, spawnRate, minObsW, maxObsW, levelScore] = getDashSettings();
        dashSpeed = speed;
        dashGravity = gravity;
        dashJump = jump;
        // Move player
        dashPlayer.x += dashSpeed;
        dashPlayer.vy += dashGravity;
        dashPlayer.y += dashPlayer.vy;
        // Ground collision
        if (dashPlayer.y + dashPlayer.h >= dashGroundY) {
            dashPlayer.y = dashGroundY - dashPlayer.h;
            dashPlayer.vy = 0;
            dashPlayer.onGround = true;
        } else {
            dashPlayer.onGround = false;
        }
        // Add obstacles
        if (dashFrame % spawnRate === 0) {
            let obsW = minObsW + Math.random()*(maxObsW-minObsW);
            dashObstacles.push({ x: W + 10, y: dashGroundY - 24, w: obsW, h: 24 });
        }
        // Move obstacles
        dashObstacles.forEach(obs => { obs.x -= dashSpeed; });
        // Remove off-screen
        dashObstacles = dashObstacles.filter(obs => obs.x + obs.w > 0);
        // Collision
        dashObstacles.forEach(obs => {
            if (
                dashPlayer.x + dashPlayer.w > obs.x &&
                dashPlayer.x < obs.x + obs.w &&
                dashPlayer.y + dashPlayer.h > obs.y &&
                dashPlayer.y < obs.y + obs.h
            ) {
                dashGameOver = true;
            }
        });
        // Score
        dashObstacles.forEach(obs => {
            if (!obs.passed && obs.x + obs.w < dashPlayer.x) {
                obs.passed = true;
                dashScore++;
            }
        });
        // End if player goes off right
        if (dashPlayer.x > W) {
            dashPlayer.x = 60;
        }
        // Level progression
        if (dashScore >= levelScore) {
            // If not last level, increment nextDashLevel for next cycle
            if (nextDashLevel < 5) nextDashLevel++;
            // Increment cyclesSurvived after each Geometry Dash completion (full cycle)
            cyclesSurvived++;
            dashMode = false;
            started = false;
            setTimeout(() => {
                // Return to Flappy Square mode for next cycle
                reset();
                started = true;
            }, 500);
            return;
        }
        // Completion message after level 5
        if (dashScore >= levelScore && dashLevel === 5) {
            dashMode = false;
            started = false;
            setTimeout(() => {
                showGameOver = true;
                showGameOverScreen();
                document.getElementById('flappyScore').textContent = 'You beat all Geometry Dash levels!';
            }, 500);
            return;
        }
        if (dashGameOver) {
            showGameOver = true;
            showGameOverScreen();
            document.getElementById('flappyScore').textContent = '';
            dashMode = false;
            started = false;
        }
    }
    function loop() {
        if (canvas.style.display === 'none') return;
        if (!gameOver && started) update();
        draw();
        frame++;
        requestAnimationFrame(loop);
    }
    function jumpBird(e) {
        if (dashMode) {
            // Jump in dash mode
            if (dashPlayer.onGround) {
                dashPlayer.vy = dashJump;
                dashPlayer.onGround = false;
            }
            return;
        }
        if (!started) {
            // Start on any click inside the canvas
            if (!readyToStart && e && e.type === 'click') {
                readyToStart = true;
                started = true;
                return;
            } else if (!readyToStart) {
                return;
            }
            reset();
            started = true;
            return;
        }
        if (!knifeMode) {
            if (!gameOver) birdV = jump;
            else { reset(); started = true; }
        } else {
            // Knife Dodge: move left/right
            if (e && e.type === 'keydown') {
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') blockV = -blockSpeed;
                else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') blockV = blockSpeed;
            } else if (e && e.type === 'click') {
                const mx = e.offsetX;
                // Move block by one step per click
                if (mx < W/2) blockX = Math.max(blockR, blockX - blockSpeed * 4);
                else blockX = Math.min(W - blockR, blockX + blockSpeed * 4);
                blockV = 0;
            } else if (e && e.type === 'touchstart') {
                const tx = e.touches[0].clientX - canvas.getBoundingClientRect().left;
                // Move block by one step per tap
                if (tx < W/2) blockX = Math.max(blockR, blockX - blockSpeed * 4);
                else blockX = Math.min(W - blockR, blockX + blockSpeed * 4);
                blockV = 0;
            }
        }
    }
    function stopBlock(e) {
        if (knifeMode) blockV = 0;
    }
    canvas.onclick = e => jumpBird({type:'click', offsetX:e.offsetX});
    canvas.ontouchstart = e => jumpBird(e);
    window.addEventListener('keydown', function(e){
        // Prevent page scroll on Space, Up, or W when game is visible
        if ((e.code === 'Space' || e.key === ' ' || e.code === 'ArrowUp' || e.key === 'w' || e.key === 'W') && document.getElementById('gameWrapper').style.display === 'block') {
            e.preventDefault();
        }
        // Flappy/Geometry Dash jump: Space, Up, W
        if (!knifeMode && (e.code==='Space' || e.key===' ' || e.code==='ArrowUp' || e.key==='w' || e.key==='W')) {
            if (gameOver) {
                // If game over, pressing jump restarts
                let overlay = document.getElementById('gameOverScreen');
                if (overlay) overlay.remove();
                reset();
                started = true;
                return;
            }
            jumpBird(e);
        }
        // Allow ArrowLeft, ArrowRight, 'a', and 'd' for boulder mode
        else if (knifeMode && (e.key==='ArrowLeft'||e.key==='ArrowRight'||e.key==='a'||e.key==='A'||e.key==='d'||e.key==='D')) jumpBird(e);
    });
    // --- Fix: ensure game starts/reset on play button ---
    // Remove the old reset/loop call at the end, and expose a startGame function
    function startGame() {
        reset();
        started = true;
        loop();
    }
    // --- Fix: hook play button to startGame ---
    document.addEventListener('DOMContentLoaded', function() {
      var playBtn = document.getElementById('playBtn');
      var gameWrapper = document.getElementById('gameWrapper');
      if (playBtn && gameWrapper) {
        playBtn.onclick = function() {
          playBtn.style.display = 'none';
          gameWrapper.style.display = 'block';
          // Start the game when play is pressed
          if (window.flappyStartGame) window.flappyStartGame();
        };
      }
    });
    // --- Expose startGame globally so playBtn can call it ---
    window.flappyStartGame = (function() {
        // Find the flappyBirdGame IIFE and extract startGame
        let startGame = null;
        for (const k in window) {
            if (typeof window[k] === 'function' && window[k].toString().includes('Flappy Mode!')) {
                // Try to find startGame in closure
                try {
                    const fn = window[k];
                    const m = fn.toString().match(/function startGame\(\) \{[\s\S]*?\}/);
                    if (m) {
                        // Not perfect, but we just call reset/started/loop
                        startGame = function() {
                            // Fallback: reload page if not found
                            location.reload();
                        };
                    }
                } catch(e) {}
            }
        }
        // Fallback: reload page if not found
        if (!startGame) startGame = function() { location.reload(); };
        return startGame;
    })();
    reset();
    loop();
})();
});
</script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  var playBtn = document.getElementById('playBtn');
  var gameWrapper = document.getElementById('gameWrapper');
  if (playBtn && gameWrapper) {
    playBtn.onclick = function() {
      playBtn.style.display = 'none';
      gameWrapper.style.display = 'block';
    };
  }
});
</script>
</body>
</html>
